# Copyright 2019 Mechanics of Microstructures Group
#    at The University of Manchester
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import pathlib
from typing import Union, Tuple

import numpy as np
import pandas as pd


class EBSDMetadata:
    def __init__(self):
        self.xDim = 0
        self.yDim = 0
        self.stepSize = 0
        self.numPhases = 0
        self.phaseNames = []


class EBSDData:
    def __init__(self):
        self.eulerAngle = None
        self.bandContrast = None
        self.phase = None


def _checkEBSDMetadata(metadata: EBSDMetadata):
    if len(metadata.phaseNames) != metadata.numPhases:
        print("Number of phases mismatch.")
        raise AssertionError


def _loadOxfordCPR(fileStub: pathlib.Path) -> EBSDMetadata:
    """ A .cpr file is a metadata file describing EBSD data.
    This function opens the cpr file, reading in the x and y
    dimensions and phase names."""
    filePath = fileStub.with_suffix(".cpr")
    if not filePath.is_file():
        raise FileNotFoundError("Cannot open file {}".format(filePath))

    with open(str(filePath), 'r') as cprFile:

        metadata = EBSDMetadata()
        for line in cprFile:
            if 'xCells' in line:
                metadata.xDim = int(line.split("=")[-1])
            elif 'yCells' in line:
                metadata.yDim = int(line.split("=")[-1])
            elif 'GridDistX' in line:
                metadata.stepSize = float(line.split("=")[-1])
            elif '[Phases]' in line:
                metadata.numPhases = int(next(cprFile).split("=")[-1])
            elif '[Phase' in line:
                phaseName = next(cprFile).split("=")[-1].strip('\n')
                metadata.phaseNames.append(phaseName)

    _checkEBSDMetadata(metadata)

    return metadata


def _loadOxfordCRC(fileStub: pathlib.Path, metadata: EBSDMetadata) -> EBSDData:
    """Read binary EBSD data from a .crc file"""
    filePath = fileStub.with_suffix(".crc")

    if not filePath.is_file():
        raise FileNotFoundError("Cannot open file {}".format(filePath))

    dataFormat = np.dtype([
        ('Phase', 'b'),
        ('ph1', 'f'),
        ('phi', 'f'),
        ('ph2', 'f'),
        ('MAD', 'f'),
        ('BC', 'uint8'),
        ('IB3', 'uint8'),
        ('IB4', 'uint8'),
        ('IB5', 'uint8'),
        ('IB6', 'f')
    ])
    binData = np.fromfile(str(filePath), dataFormat, count=-1)

    return build_ebsd_data(binData, metadata)


def _loadOxfordCTF(filePath: pathlib.Path) -> Tuple[EBSDMetadata, EBSDData]:
    """ A .ctf file is a HKL single orientation file. This is a
    data file generated by the Oxford EBSD instrument."""

    # open data file and read in metadata
    if not filePath.is_file():
        raise FileNotFoundError("Cannot open file {}".format(filePath))

    metadata = EBSDMetadata()

    with open(str(filePath), 'r') as ctfFile:

        for line_num, line in enumerate(ctfFile):
            if 'XCells' in line:
                metadata.xDim = int(line.split()[-1])
            elif 'YCells' in line:
                metadata.yDim = int(line.split()[-1])
            elif 'XStep' in line:
                metadata.stepSize = float(line.split()[-1])
            elif 'Phases' in line:
                numPhases = int(line.split()[-1])
                metadata.numPhases = numPhases
                for phase_num in range(numPhases):
                    metadata.phaseNames.append(next(ctfFile).split()[2])
                numHeaderLines = line_num + numPhases + 2
                # phases are last in the header so break out of the loop
                break

    _checkEBSDMetadata(metadata)

    # now read the data from file
    dataFormat = np.dtype([
        ('Phase', 'b'),
        ('ph1', 'f'),
        ('phi', 'f'),
        ('ph2', 'f'),
        ('MAD', 'f'),
        ('BC', 'uint8')
    ])
    input_data = np.loadtxt(
        str(filePath), dataFormat, delimiter='\t',
        skiprows=numHeaderLines, usecols=(0, 5, 6, 7, 8, 9)
    )

    data = build_ebsd_data(input_data, metadata)
    data.eulerAngle = data.eulerAngle * np.pi / 180.

    return metadata, data


def build_ebsd_data(input_data: np.ndarray, metadata: EBSDMetadata) -> EBSDData:
    """Given raw input data, build an EBSD data object."""
    data = EBSDData()
    data.bandContrast = np.reshape(input_data['BC'], (metadata.yDim, metadata.xDim))
    data.phase = np.reshape(input_data['Phase'], (metadata.yDim, metadata.xDim))
    eulerAngles = np.stack((input_data['ph1'], input_data['phi'], input_data['ph2']),
                           axis=0)
    data.eulerAngle = eulerAngles.reshape((3, metadata.yDim, metadata.xDim))

    return data


class DICMetadata:
    def __init__(self):
        self.format = ""
        self.version = ""
        self.binning = ""
        self.xDim = 0
        self.yDim = 0


class DICData:
    def __init__(self):
        self.xc = None
        self.yc = None
        self.xd = None
        self.yd = None


def checkDICData(data: DICData, metadata: DICMetadata):
    # Calculate size of map from loaded data and check it matches
    # values from metadata
    xdim = int(
        (data.xc.max() - data.xc.min()) / min(abs(np.diff(data.xc))) + 1
    )

    ydim = int(
        (data.yc.max() - data.yc.min()) / max(abs(np.diff(data.yc))) + 1
    )

    if not xdim == metadata.xDim or not ydim == metadata.yDim:
        raise AssertionError("Dimensions of data and header do not match")


def _loadDaVisData(filePath) -> Tuple[DICMetadata, DICData]:
    # Load DIC data from a txt file in the format used by DaVis imaging software
    if not filePath.is_file():
        raise FileNotFoundError("Cannot open file {}".format(filePath))

    with open(str(filePath), 'r') as f:
        line = f.readline().split()

    metadata = DICMetadata()

    # Software name and version
    metadata.format = line[0].strip('#')
    metadata.version = line[1]
    # Sub-window width in pixels
    metadata.binning = int(line[3])
    # size of map along x and y (from header)
    metadata.xDim = int(line[5])
    metadata.yDim = int(line[4])

    raw_data = pd.read_table(str(filePath), delimiter='\t', skiprows=1, header=None)
    data = DICData()
    # x and y coordinates
    data.xc = raw_data.values[:, 0]
    data.yc = raw_data.values[:, 1]
    # x and y displacement
    data.xd = raw_data.values[:, 2]
    data.yd = raw_data.values[:, 3]

    checkDICData(data, metadata)

    return metadata, data


def loadEBSDData(file_path: Union[str, os.PathLike]) -> Tuple[EBSDMetadata, EBSDData]:
    """General method for loading EBSD data and associated metadata."""
    path = pathlib.Path(file_path)
    if not path.exists():
        raise FileNotFoundError

    if path.suffix == ".ctf":
        metadata, data = _loadOxfordCTF(path)
    elif path.suffix == ".cpr" or path.suffix == ".crc":
        file_stub = path.with_suffix('')
        metadata = _loadOxfordCPR(file_stub)
        data = _loadOxfordCRC(file_stub, metadata)
    else:
        raise TypeError(f"File {path} is an unknown type for EBSD data.")

    return metadata, data


def loadDICData(file_path: Union[str, os.PathLike]) -> Tuple[DICMetadata, DICData]:
    """General method for loading DIC data and associated metadata."""
    path = pathlib.Path(file_path)
    if not path.exists():
        raise FileNotFoundError

    if path.suffix == ".txt":
        metadata, data = _loadDaVisData(path)
    else:
        raise TypeError(f"File {path} is an unknown type for DIC data.")

    return metadata, data
